#!/usr/bin/env python3
"""
setup_detekt.py - Set up Detekt with Kotlin-in-Action aligned rules.

Usage:
    python setup_detekt.py [--output-dir ./]

Generates:
    detekt.yml      - Detekt config with rules mapped to Kotlin in Action chapters
    run_detekt.sh   - Shell script to run Detekt with this config

Each rule includes a comment referencing the relevant chapter from
"Kotlin in Action" by Dmitry Jemerov and Svetlana Isakova.
"""

import argparse
import pathlib
import stat

DETEKT_YML = """\
# detekt.yml
# Detekt configuration aligned with "Kotlin in Action" by Jemerov & Isakova.
# Each rule references the chapter that motivates it.

build:
  maxIssues: 0
  excludeCorrectable: false

config:
  validation: true
  warningsAsErrors: false

complexity:
  active: true

  # Chapter 5 - Lambdas: keep lambdas and functions concise and readable.
  LongMethod:
    active: true
    threshold: 20

  # Chapter 3 - Functions: prefer functions with few, well-named parameters.
  # Many parameters suggest the need for a data class or builder pattern.
  LongParameterList:
    active: true
    functionThreshold: 4
    constructorThreshold: 6
    ignoreDefaultParameters: true

  # Chapter 10 - Higher-order functions: avoid deep nesting; flatten with
  # higher-order functions (map, filter, let, run) instead.
  NestedBlockDepth:
    active: true
    threshold: 3

  # Chapter 4 - Classes: classes should be focused and not overly complex.
  TooManyFunctions:
    active: true
    thresholdInFiles: 20
    thresholdInClasses: 15
    thresholdInInterfaces: 10
    thresholdInObjects: 10
    thresholdInEnums: 5

naming:
  active: true

  # Chapter 3 - Functions: Kotlin convention is camelCase for function names.
  FunctionNaming:
    active: true
    functionPattern: '[a-z][a-zA-Z0-9]*'
    excludes: ['**/test/**']

  # Chapter 2 - Basics: variables follow camelCase; properties are idiomatic Kotlin.
  VariableNaming:
    active: true
    variablePattern: '[a-z][a-zA-Z0-9]*'
    privateVariablePattern: '(_)?[a-z][a-zA-Z0-9]*'

  # Chapter 4 - Classes: class names are PascalCase per Kotlin convention.
  ClassNaming:
    active: true
    classPattern: '[A-Z][a-zA-Z0-9]*'

  # Chapter 8 - Generics: type parameter names should be single uppercase letters
  # or descriptive PascalCase names.
  TypeParameterNaming:
    active: true
    typeParameterPattern: '[A-Z][A-Za-z]*'

style:
  active: true

  # Chapter 4 - Classes, Objects, Interfaces: abstract classes without abstract
  # members should be interfaces or open classes instead.
  UnnecessaryAbstractClass:
    active: true

  # Chapter 3 - Functions: Unit return type is implicit; declaring it is redundant.
  OptionalUnit:
    active: true

  # Chapter 2 - Basics: val properties that can be const should be const
  # for compile-time optimisation.
  MayBeConst:
    active: true

  # Chapter 4 - Objects: use object declarations instead of classes with only
  # static members.
  UseDataClass:
    active: true
    allowVars: false

  # Chapter 11 - DSL: trailing lambdas should be outside parentheses per convention.
  UnnecessaryParentheses:
    active: true

potential-bugs:
  active: true

  # Chapter 6 - Null Safety: lateinit signals deferred initialisation, which
  # makes nullability guarantees harder to reason about. Prefer constructor injection.
  LateinitUsage:
    active: true
    excludes: ['**/test/**']
    ignoreOnClassesPattern: ''

  # Chapter 6 - Null Safety: the !! operator bypasses null safety and will
  # throw NPE at runtime. Use safe calls (?.) or Elvis operator (?:) instead.
  UnsafeCallOnNullableType:
    active: true
    excludes: ['**/test/**']

  # Chapter 6 - Null Safety: explicit null checks with == null should be
  # replaced with safe-call or let idioms.
  NullableToStringCall:
    active: true

coroutines:
  active: true

  # Chapter 12 (Appendix) - Coroutines: GlobalScope couples coroutines to
  # application lifetime and makes cancellation impossible. Use structured
  # concurrency with a scoped CoroutineScope instead.
  GlobalCoroutineUsage:
    active: true

  # Chapter 12 - Coroutines: suspend modifier on a function that contains no
  # suspension points is misleading and adds unnecessary overhead.
  RedundantSuspendModifier:
    active: true

  # Chapter 12 - Coroutines: use withContext for blocking calls rather than
  # running them on the default dispatcher.
  BlockingMethodInNonBlockingContext:
    active: true
"""

RUN_SCRIPT = """\
#!/usr/bin/env bash
# run_detekt.sh
# Runs Detekt with the Kotlin-in-Action aligned configuration.
# Generated by setup_detekt.py

set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
CONFIG="${SCRIPT_DIR}/detekt.yml"
SRC_DIR="${1:-src}"

if ! command -v detekt &>/dev/null && ! command -v detekt-cli &>/dev/null; then
  echo "ERROR: detekt not found on PATH."
  echo ""
  echo "Install options:"
  echo "  brew install detekt          # macOS"
  echo "  sdk install detekt           # SDKMAN"
  echo "  # Or run via Gradle plugin - add to build.gradle.kts:"
  echo "  #   plugins { id(\\"io.gitlab.arturbosch.detekt\\") version \\"1.23.5\\" }"
  exit 1
fi

CMD="detekt"
command -v detekt-cli &>/dev/null && CMD="detekt-cli"

echo "Running Detekt on $SRC_DIR ..."
$CMD --config "$CONFIG" --input "$SRC_DIR"
echo "Done."
"""


def write_file(path: pathlib.Path, content: str, executable: bool = False) -> None:
    path.write_text(content, encoding="utf-8")
    if executable:
        path.chmod(path.stat().st_mode | stat.S_IXUSR | stat.S_IXGRP | stat.S_IXOTH)
    print(f"Wrote: {path}")


def main() -> None:
    parser = argparse.ArgumentParser(
        description="Set up Detekt with Kotlin-in-Action aligned rules."
    )
    parser.add_argument(
        "--output-dir",
        default=".",
        help="Directory to write config files (default: ./)",
    )
    args = parser.parse_args()

    output_dir = pathlib.Path(args.output_dir).resolve()
    output_dir.mkdir(parents=True, exist_ok=True)

    write_file(output_dir / "detekt.yml", DETEKT_YML)
    write_file(output_dir / "run_detekt.sh", RUN_SCRIPT, executable=True)

    print()
    print("Setup complete.")
    print(f"  Config : {output_dir / 'detekt.yml'}")
    print(f"  Runner : {output_dir / 'run_detekt.sh'}")
    print()
    print("Run Detekt:")
    print(f"  cd {output_dir} && ./run_detekt.sh [src-dir]")


if __name__ == "__main__":
    main()
