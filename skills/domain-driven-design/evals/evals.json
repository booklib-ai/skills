{
  "evals": [
    {
      "id": "eval-01-anemic-domain-model",
      "prompt": "Review this code for a loan application system:\n\n```java\n// Domain object — just data\npublic class LoanApplication {\n    private String applicantId;\n    private BigDecimal requestedAmount;\n    private int termMonths;\n    private String status; // PENDING, APPROVED, REJECTED, DISBURSED\n    private BigDecimal approvedAmount;\n    private String rejectionReason;\n    private LocalDate applicationDate;\n    private String reviewerId;\n    \n    // getters and setters for all fields...\n}\n\n// All logic lives here\npublic class LoanApplicationService {\n    private LoanApplicationRepository repository;\n    private CreditScoreService creditScoreService;\n    private RiskEngine riskEngine;\n    \n    public void approveLoan(String applicationId, String reviewerId, BigDecimal approvedAmount) {\n        LoanApplication application = repository.findById(applicationId);\n        if (!application.getStatus().equals(\"PENDING\")) {\n            throw new IllegalStateException(\"Can only approve PENDING applications\");\n        }\n        if (approvedAmount.compareTo(application.getRequestedAmount()) > 0) {\n            throw new IllegalArgumentException(\"Approved amount cannot exceed requested amount\");\n        }\n        application.setStatus(\"APPROVED\");\n        application.setApprovedAmount(approvedAmount);\n        application.setReviewerId(reviewerId);\n        repository.save(application);\n    }\n    \n    public void rejectLoan(String applicationId, String reviewerId, String reason) {\n        LoanApplication application = repository.findById(applicationId);\n        if (!application.getStatus().equals(\"PENDING\")) {\n            throw new IllegalStateException(\"Can only reject PENDING applications\");\n        }\n        application.setStatus(\"REJECTED\");\n        application.setRejectionReason(reason);\n        application.setReviewerId(reviewerId);\n        repository.save(application);\n    }\n    \n    public boolean isEligibleForFastTrack(String applicationId) {\n        LoanApplication application = repository.findById(applicationId);\n        int creditScore = creditScoreService.getScore(application.getApplicantId());\n        return creditScore > 750 && application.getRequestedAmount().compareTo(new BigDecimal(\"50000\")) <= 0;\n    }\n}\n```",
      "expectations": [
        "Identifies this as an Anemic Domain Model — LoanApplication is a data bag with no behavior, all logic pushed into the service layer",
        "Flags that approve() and reject() are domain operations that belong on the LoanApplication aggregate, not in the service",
        "Notes that the invariant 'can only approve PENDING applications' is a business rule that LoanApplication should enforce internally",
        "Flags Primitive Obsession: status as String instead of a LoanStatus enum or Value Object; applicantId and reviewerId as raw Strings instead of typed Value Objects (ApplicantId, ReviewerId)",
        "Notes that requestedAmount and approvedAmount should be a Money Value Object (amount + currency), not a bare BigDecimal",
        "Points out that the service directly sets fields via setters (setStatus, setApprovedAmount) — bypasses any invariant enforcement and breaks encapsulation",
        "Recommends moving approve(ReviewerId reviewerId, Money approvedAmount) and reject(ReviewerId reviewerId, String reason) methods onto LoanApplication itself",
        "Suggests that the service layer should be thin: load aggregate → call domain method → save",
        "References the anti-pattern: 'Transaction Script masquerading as DDD — procedural service methods that manipulate passive data objects'"
      ]
    },
    {
      "id": "eval-02-missing-value-object",
      "prompt": "Review this code for a shipping system:\n\n```java\npublic class Shipment {\n    private String id;\n    private String recipientName;\n    private String streetAddress;\n    private String city;\n    private String stateCode;\n    private String postalCode;\n    private String countryCode;\n    private String senderName;\n    private String senderStreet;\n    private String senderCity;\n    private String senderStateCode;\n    private String senderPostalCode;\n    private String senderCountryCode;\n    private double weightKg;\n    private double lengthCm;\n    private double widthCm;\n    private double heightCm;\n    private String trackingNumber;\n    private String status;\n    \n    public double calculateVolumetricWeight() {\n        return (lengthCm * widthCm * heightCm) / 5000.0;\n    }\n    \n    public double getBillableWeight() {\n        double volumetric = calculateVolumetricWeight();\n        return Math.max(weightKg, volumetric);\n    }\n    \n    public boolean isInternational() {\n        return !senderCountryCode.equals(countryCode);\n    }\n    \n    public String formatRecipientAddress() {\n        return recipientName + \"\\n\" + streetAddress + \"\\n\" +\n               city + \", \" + stateCode + \" \" + postalCode + \"\\n\" + countryCode;\n    }\n    \n    public String formatSenderAddress() {\n        return senderName + \"\\n\" + senderStreet + \"\\n\" +\n               senderCity + \", \" + senderStateCode + \" \" + senderPostalCode + \"\\n\" + senderCountryCode;\n    }\n}\n```",
      "expectations": [
        "Identifies the missing Value Objects: Address (street, city, state, postal code, country) is a natural concept that is duplicated for sender and recipient",
        "Identifies a second Value Object: Dimensions (length, width, height) with volumetric weight behavior",
        "Identifies a third Value Object candidate: Weight (value + unit — kg is baked into the field name but not the type)",
        "Notes that the Shipment Entity is bloated with 19 fields — a God Entity collecting too many responsibilities",
        "Points out that formatRecipientAddress() and formatSenderAddress() are the same logic duplicated with different field names — a symptom of not having an Address Value Object",
        "Notes that calculateVolumetricWeight() belongs on a Dimensions Value Object, not on Shipment",
        "Flags Primitive Obsession: all fields are raw strings/doubles instead of typed domain concepts",
        "Recommends concrete refactoring: extract Address, Dimensions, Weight Value Objects; Shipment holds Address recipient, Address sender, Dimensions, Weight",
        "Notes Value Objects should be immutable with attribute-based equality"
      ]
    },
    {
      "id": "eval-03-well-designed-aggregate",
      "prompt": "Review this domain model for a bank account system:\n\n```java\npublic class AccountId {\n    private final String value;\n    \n    public AccountId(String value) {\n        if (value == null || value.isBlank()) throw new IllegalArgumentException(\"AccountId cannot be blank\");\n        this.value = value;\n    }\n    \n    public String getValue() { return value; }\n    \n    @Override public boolean equals(Object o) {\n        if (this == o) return true;\n        if (!(o instanceof AccountId)) return false;\n        return value.equals(((AccountId) o).value);\n    }\n    @Override public int hashCode() { return value.hashCode(); }\n}\n\npublic class Money {\n    private final BigDecimal amount;\n    private final Currency currency;\n    \n    public Money(BigDecimal amount, Currency currency) {\n        if (amount == null || currency == null) throw new IllegalArgumentException();\n        this.amount = amount;\n        this.currency = currency;\n    }\n    \n    public Money add(Money other) {\n        if (!this.currency.equals(other.currency)) throw new IllegalArgumentException(\"Currency mismatch\");\n        return new Money(this.amount.add(other.amount), this.currency);\n    }\n    \n    public Money subtract(Money other) {\n        if (!this.currency.equals(other.currency)) throw new IllegalArgumentException(\"Currency mismatch\");\n        return new Money(this.amount.subtract(other.amount), this.currency);\n    }\n    \n    public boolean isNegative() { return amount.compareTo(BigDecimal.ZERO) < 0; }\n    \n    // equals, hashCode based on amount and currency\n}\n\npublic class BankAccount {\n    private final AccountId id;\n    private Money balance;\n    private final List<Transaction> ledger;\n    private AccountStatus status;\n    \n    private BankAccount(AccountId id, Money initialBalance) {\n        this.id = id;\n        this.balance = initialBalance;\n        this.ledger = new ArrayList<>();\n        this.status = AccountStatus.ACTIVE;\n    }\n    \n    public static BankAccount open(AccountId id, Money initialDeposit) {\n        if (initialDeposit.isNegative()) throw new IllegalArgumentException(\"Initial deposit must be positive\");\n        return new BankAccount(id, initialDeposit);\n    }\n    \n    public void deposit(Money amount) {\n        if (status != AccountStatus.ACTIVE) throw new IllegalStateException(\"Cannot deposit to a \" + status + \" account\");\n        if (amount.isNegative()) throw new IllegalArgumentException(\"Deposit amount must be positive\");\n        this.balance = this.balance.add(amount);\n        ledger.add(Transaction.credit(amount));\n    }\n    \n    public void withdraw(Money amount) {\n        if (status != AccountStatus.ACTIVE) throw new IllegalStateException(\"Cannot withdraw from a \" + status + \" account\");\n        if (amount.isNegative()) throw new IllegalArgumentException(\"Withdrawal amount must be positive\");\n        Money newBalance = this.balance.subtract(amount);\n        if (newBalance.isNegative()) throw new DomainException(\"Insufficient funds\");\n        this.balance = newBalance;\n        ledger.add(Transaction.debit(amount));\n    }\n    \n    public void close() {\n        if (!balance.equals(Money.zero(balance.getCurrency()))) {\n            throw new DomainException(\"Cannot close account with non-zero balance\");\n        }\n        this.status = AccountStatus.CLOSED;\n    }\n    \n    public Money getBalance() { return balance; }\n    public List<Transaction> getLedger() { return Collections.unmodifiableList(ledger); }\n    public AccountId getId() { return id; }\n}\n```",
      "expectations": [
        "Recognizes this as a well-designed Aggregate and says so explicitly",
        "Praises AccountId and Money as properly modeled Value Objects — immutable, attribute-based equality, validated in constructor",
        "Praises the factory method BankAccount.open() for enforcing invariants at creation time",
        "Praises that all business rules (no overdraft, no deposit to closed account, cannot close with balance) are enforced inside the aggregate rather than in a service layer",
        "Praises that getLedger() returns an unmodifiable list — protecting the internal collection from external mutation",
        "Praises the closed constructor — external code cannot create a BankAccount without going through the factory method",
        "Does NOT manufacture fake issues just to have something to say",
        "May offer optional suggestions (domain events for deposit/withdrawal, separate TransactionId Value Object) but clearly frames them as enhancements, not defects"
      ]
    }
  ]
}
