{
  "evals": [
    {
      "id": "eval-01-distributed-transaction-no-saga",
      "prompt": "Review this microservices code for an e-commerce checkout flow:\n\n```java\n// OrderService — orchestrates the entire checkout in one HTTP transaction\n@RestController\npublic class CheckoutController {\n    private final OrderRepository orderRepository;\n    private final InventoryServiceClient inventoryClient;\n    private final PaymentServiceClient paymentClient;\n    private final ShippingServiceClient shippingClient;\n    private final NotificationServiceClient notificationClient;\n    \n    @PostMapping(\"/checkout\")\n    @Transactional  // <-- spans the entire method\n    public OrderConfirmation checkout(@RequestBody CheckoutRequest request) {\n        // Step 1: Reserve inventory\n        inventoryClient.reserveItems(request.getItems());\n        \n        // Step 2: Create order in our DB\n        Order order = orderRepository.save(new Order(request));\n        \n        // Step 3: Charge payment\n        PaymentResult payment = paymentClient.charge(request.getPaymentInfo(), order.getTotal());\n        \n        // Step 4: Create shipping label\n        ShippingLabel label = shippingClient.createLabel(order.getId(), request.getAddress());\n        \n        // Step 5: Send confirmation email\n        notificationClient.sendConfirmation(request.getEmail(), order.getId());\n        \n        order.setShippingLabel(label.getTrackingNumber());\n        order.setStatus(\"CONFIRMED\");\n        return new OrderConfirmation(order.getId(), label.getTrackingNumber());\n    }\n}\n```",
      "expectations": [
        "Identifies the core anti-pattern: a distributed transaction where @Transactional spans HTTP calls to 3 external services — this does not work as intended",
        "Explains why @Transactional cannot span HTTP calls: the ACID transaction boundary is the local database only; remote service calls are not rolled back if a later step fails",
        "Identifies the failure scenario: if shippingClient.createLabel() throws after paymentClient.charge() succeeds, the customer is charged but never gets a shipping label — and inventory is reserved but no rollback occurs",
        "Names the pattern that is needed: the Saga pattern (orchestration-based) to handle this cross-service workflow",
        "Explains compensating transactions: each step needs a corresponding undo — if shipping fails, a ReversePaymentSaga step should issue a refund and a ReleaseInventory step should free reserved stock",
        "Notes the synchronous chain anti-pattern: OrderService → Inventory → Payment → Shipping → Notification is a fragile chain — if Notification is slow or down, the entire checkout hangs",
        "Recommends making notifications asynchronous via a message queue (fire-and-forget)",
        "Suggests using Saga orchestration with explicit saga states (PENDING_INVENTORY, PENDING_PAYMENT, PENDING_SHIPPING, CONFIRMED, FAILED) stored durably"
      ]
    },
    {
      "id": "eval-02-shared-database",
      "prompt": "Review this microservices architecture:\n\n```java\n// ProductService — manages product catalog\n@Service\npublic class ProductService {\n    @Autowired\n    private JdbcTemplate jdbc;  // Connects to: jdbc:postgresql://shared-db:5432/platform\n    \n    public Product getProduct(Long id) {\n        return jdbc.queryForObject(\n            \"SELECT * FROM products WHERE id = ?\",\n            new ProductRowMapper(), id);\n    }\n    \n    public void updatePrice(Long productId, BigDecimal newPrice) {\n        jdbc.update(\"UPDATE products SET price = ?, updated_at = NOW() WHERE id = ?\",\n            newPrice, productId);\n    }\n}\n\n// OrderService — in a SEPARATE deployable service/process\n@Service\npublic class OrderService {\n    @Autowired\n    private JdbcTemplate jdbc;  // ALSO connects to: jdbc:postgresql://shared-db:5432/platform\n    \n    public Order createOrder(CreateOrderRequest req) {\n        // Directly reads from products table owned by ProductService\n        BigDecimal price = jdbc.queryForObject(\n            \"SELECT price FROM products WHERE id = ?\",\n            BigDecimal.class, req.getProductId());\n        \n        // Directly joins across service boundaries\n        List<OrderLine> lines = jdbc.query(\n            \"SELECT o.*, p.name, p.sku FROM orders o JOIN products p ON o.product_id = p.id WHERE o.customer_id = ?\",\n            new OrderLineRowMapper(), req.getCustomerId());\n        \n        jdbc.update(\"INSERT INTO orders (product_id, customer_id, price) VALUES (?, ?, ?)\",\n            req.getProductId(), req.getCustomerId(), price);\n        return buildOrder(lines);\n    }\n}\n```",
      "expectations": [
        "Identifies the Shared Database anti-pattern: both ProductService and OrderService connect to the same database and directly access each other's tables",
        "Explains why this is problematic: ProductService cannot change its products table schema without coordinating with OrderService — the services are coupled at the data layer despite being separate deployables",
        "Flags that OrderService reads from products — meaning ProductService's internal data model is now OrderService's public API; any rename or restructure breaks OrderService",
        "Flags the cross-service JOIN in SQL: joins across service boundaries are a strong indicator of incorrect service decomposition or a shared database violation",
        "Explains the correct pattern: each service owns its own database/schema; OrderService should get product information by calling ProductService's API (synchronous) or by maintaining a local read model via events (CQRS)",
        "Recommends that OrderService should store the price at order-creation time (denormalized) rather than joining live to the products table — price at time of purchase is correct business behavior",
        "Notes that this architecture makes independent deployment impossible: upgrading ProductService's database schema requires a coordinated deployment with OrderService"
      ]
    },
    {
      "id": "eval-03-event-driven-saga",
      "prompt": "Review this saga implementation for a ride-sharing trip booking:\n\n```java\n// TripSaga — orchestrator (Spring Saga / Axon-style pseudocode)\n@Saga\npublic class BookTripSaga {\n    private String tripId;\n    private String driverId;\n    private String paymentAuthId;\n    \n    @StartSaga\n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(TripRequestedEvent event) {\n        this.tripId = event.getTripId();\n        commandGateway.send(new FindAvailableDriverCommand(event.getTripId(), event.getLocation()));\n    }\n    \n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(DriverAssignedEvent event) {\n        this.driverId = event.getDriverId();\n        commandGateway.send(new AuthorizePaymentCommand(event.getTripId(), event.getEstimatedFare()));\n    }\n    \n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(PaymentAuthorizedEvent event) {\n        this.paymentAuthId = event.getAuthorizationId();\n        commandGateway.send(new ConfirmTripCommand(tripId, driverId));\n    }\n    \n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(NoDriverAvailableEvent event) {\n        commandGateway.send(new CancelTripCommand(tripId, \"No drivers available\"));\n        SagaLifecycle.end();\n    }\n    \n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(PaymentDeclinedEvent event) {\n        // Compensate: release the reserved driver\n        commandGateway.send(new ReleaseDriverCommand(driverId, tripId));\n        commandGateway.send(new CancelTripCommand(tripId, \"Payment declined\"));\n        SagaLifecycle.end();\n    }\n    \n    @EndSaga\n    @SagaEventHandler(associationProperty = \"tripId\")\n    public void on(TripConfirmedEvent event) {\n        // Saga complete — trip is live\n    }\n}\n```",
      "expectations": [
        "Recognizes this as a well-designed orchestration-based saga and says so explicitly",
        "Praises the compensating transactions: PaymentDeclinedEvent triggers both ReleaseDriverCommand and CancelTripCommand — each forward step has a corresponding undo",
        "Praises that the saga stores intermediate state (driverId, paymentAuthId) to enable compensation — the saga has the information it needs to undo each step",
        "Praises that the saga is event-driven: each step reacts to an event rather than making synchronous calls — this decouples the booking flow from service availability",
        "Praises explicit saga lifecycle management: SagaLifecycle.end() on failure paths and @EndSaga on success ensure the saga doesn't leak memory",
        "Praises modeling failure paths as first-class events (NoDriverAvailableEvent, PaymentDeclinedEvent) — not exceptions, but domain events the saga handles explicitly",
        "Does NOT manufacture fake issues just to have something to say",
        "May offer optional suggestions (timeout handling if DriverAssignedEvent never arrives, idempotent command handlers) but frames them as additional robustness, not defects in the current design"
      ]
    }
  ]
}
